import { BrowserWindow, screen, app } from "electron";
import { AppState } from "./main";
import path from "node:path";

const isEnvDev = process.env.NODE_ENV === "development";
const isPackaged = app.isPackaged;
const inAppBundle =
  process.execPath.includes(".app/") || process.execPath.includes(".app\\");

console.log(
  `[WindowHelper] isEnvDev: ${isEnvDev}, isPackaged: ${isPackaged}, inAppBundle: ${inAppBundle}`,
);

// Force production mode if running as packaged app or inside app bundle
const isDev = isEnvDev && !isPackaged;

const startUrl = isDev
  ? "http://localhost:5180"
  : `file://${path.join(__dirname, "../dist/index.html")}`;

export class WindowHelper {
  private launcherWindow: BrowserWindow | null = null;
  private overlayWindow: BrowserWindow | null = null;
  private isWindowVisible: boolean = false;
  // Position/Size tracking for Launcher
  private launcherPosition: { x: number; y: number } | null = null;
  private launcherSize: { width: number; height: number } | null = null;
  // Track current window mode (persists even when overlay is hidden via Cmd+B)
  private currentWindowMode: "launcher" | "overlay" = "launcher";

  private appState: AppState;

  // Initialize with explicit number type and 0 value
  private screenWidth: number = 0;
  private screenHeight: number = 0;

  // Movement variables (apply to active window)
  private step: number = 20;
  private currentX: number = 0;
  private currentY: number = 0;

  constructor(appState: AppState) {
    this.appState = appState;
  }

  public setContentProtection(enable: boolean): void {
    if (this.launcherWindow && !this.launcherWindow.isDestroyed()) {
      this.launcherWindow.setContentProtection(enable);
    }
    if (this.overlayWindow && !this.overlayWindow.isDestroyed()) {
      this.overlayWindow.setContentProtection(enable);
    }
    console.log(`[WindowHelper] Content Protection set to: ${enable}`);
  }

  public setWindowDimensions(width: number, height: number): void {
    const activeWindow = this.getMainWindow(); // Gets currently focused/relevant window
    if (!activeWindow || activeWindow.isDestroyed()) return;

    const [currentX, currentY] = activeWindow.getPosition();
    const primaryDisplay = screen.getPrimaryDisplay();
    const workArea = primaryDisplay.workAreaSize;
    const maxAllowedWidth = Math.floor(workArea.width * 0.9);
    const newWidth = Math.min(width, maxAllowedWidth);
    const newHeight = Math.ceil(height);
    const maxX = workArea.width - newWidth;
    const newX = Math.min(Math.max(currentX, 0), maxX);

    activeWindow.setBounds({
      x: newX,
      y: currentY,
      width: newWidth,
      height: newHeight,
    });

    // Update internal tracking if it's launcher
    if (activeWindow === this.launcherWindow) {
      this.launcherSize = { width: newWidth, height: newHeight };
      this.launcherPosition = { x: newX, y: currentY };
    }
  }

  // Dedicated method for overlay window resizing - decoupled from launcher
  public setOverlayDimensions(width: number, height: number): void {
    if (!this.overlayWindow || this.overlayWindow.isDestroyed()) return;
    console.log("[WindowHelper] setOverlayDimensions:", width, height);

    const [currentX, currentY] = this.overlayWindow.getPosition();
    const primaryDisplay = screen.getPrimaryDisplay();
    const workArea = primaryDisplay.workAreaSize;
    const maxAllowedWidth = Math.floor(workArea.width * 0.9);
    const maxAllowedHeight = Math.floor(workArea.height * 0.9);
    const newWidth = Math.min(Math.max(width, 300), maxAllowedWidth); // min 300, max 90%
    const newHeight = Math.min(Math.max(height, 1), maxAllowedHeight); // min 1, max 90%
    const maxX = workArea.width - newWidth;
    const maxY = workArea.height - newHeight;
    const newX = Math.min(Math.max(currentX, 0), maxX);
    const newY = Math.min(Math.max(currentY, 0), maxY);

    this.overlayWindow.setContentSize(newWidth, newHeight);
    this.overlayWindow.setPosition(newX, newY);
  }

  public createWindow(): void {
    if (this.launcherWindow !== null) return; // Already created

    const primaryDisplay = screen.getPrimaryDisplay();
    const workArea = primaryDisplay.workArea;
    this.screenWidth = workArea.width;
    this.screenHeight = workArea.height;

    // Fixed dimensions per user request
    const width = 1200;
    const height = 800;

    // Calculate centered X, and top-centered Y (5% from top)
    const x = Math.round(workArea.x + (workArea.width - width) / 2);
    // Ensure y is at least workArea.y (don't go offscreen top)
    const topMargin = Math.round(workArea.height * 0.05);
    const y = Math.round(workArea.x + topMargin);

    // --- 1. Create Launcher Window ---
    const launcherSettings: Electron.BrowserWindowConstructorOptions = {
      width: width,
      height: height,
      x: x,
      y: y,
      minWidth: 600,
      minHeight: 400,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, "preload.js"),
        scrollBounce: true,
        webSecurity: true,
      },
      show: false, // DEBUG: Force show -> Fixed white screen, now relies on ready-to-show
      titleBarStyle: "hiddenInset",
      trafficLightPosition: { x: 14, y: 14 },
      vibrancy: "under-window",
      visualEffectState: "followWindow",
      transparent: false, // DEBUG: Disable transparency
      hasShadow: true,
      backgroundColor: "#000000", // Fixed: Black background to match startup sequence
      focusable: true,
      resizable: true,
      movable: true,
      center: true,
      icon: app.isPackaged
        ? path.join(process.resourcesPath, "rustyn.icns")
        : path.resolve(__dirname, "../assets/rustyn.icns"),
    };

    console.log(`[WindowHelper] Icon Path: ${launcherSettings.icon}`);
    console.log(`[WindowHelper] Start URL: ${startUrl}`);

    try {
      this.launcherWindow = new BrowserWindow(launcherSettings);
      console.log("[WindowHelper] BrowserWindow created successfully");
    } catch (err) {
      console.error("[WindowHelper] Failed to create BrowserWindow:", err);
      return;
    }

    this.launcherWindow.setContentProtection(false);

    // Allow CORS responses from the backend API so fetch works from file:// origin
    this.launcherWindow.webContents.session.webRequest.onHeadersReceived(
      { urls: ["https://rustyn-ai-one.vercel.app/*"] },
      (details, callback) => {
        const headers = Object.assign({}, details.responseHeaders, {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Headers":
            "Content-Type, Authorization, X-Requested-With",
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        });
        callback({ responseHeaders: headers });
      },
    );

    this.launcherWindow
      .loadURL(`${startUrl}?window=launcher`)
      .then(() => console.log("[WindowHelper] loadURL success"))
      .catch((e) => {
        console.error("[WindowHelper] Failed to load URL:", e);
      });

    this.launcherWindow.webContents.on(
      "did-fail-load",
      (event, errorCode, errorDescription) => {
        console.error(
          `[WindowHelper] did-fail-load: ${errorCode} ${errorDescription}`,
        );
      },
    );

    if (isDev) {
      this.launcherWindow.webContents.openDevTools({ mode: "detach" }); // DEBUG: Open DevTools
    }

    // --- 2. Create Overlay Window (Hidden initially) ---
    const overlaySettings: Electron.BrowserWindowConstructorOptions = {
      width: 600,
      height: 1,
      minWidth: 300,
      minHeight: 1,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        preload: path.join(__dirname, "preload.js"),
        scrollBounce: true,
      },
      show: false,
      frame: false, // Frameless
      transparent: true,
      backgroundColor: "#00000000",
      alwaysOnTop: true,
      focusable: true,
      resizable: false, // Enforce automatic resizing only
      movable: true,
      skipTaskbar: true, // Don't show separately in dock/taskbar
      hasShadow: false, // Prevent shadow from adding perceived size/artifacts
    };

    this.overlayWindow = new BrowserWindow(overlaySettings);
    this.overlayWindow.setContentProtection(false);

    if (process.platform === "darwin") {
      this.overlayWindow.setVisibleOnAllWorkspaces(true, {
        visibleOnFullScreen: true,
      });
      this.overlayWindow.setHiddenInMissionControl(true);
      this.overlayWindow.setAlwaysOnTop(true, "floating");
    }

    this.overlayWindow.loadURL(`${startUrl}?window=overlay`).catch(() => {});

    // --- 3. Startup Sequence ---
    this.launcherWindow.once("ready-to-show", () => {
      this.launcherWindow?.show();
      this.launcherWindow?.focus();
      this.isWindowVisible = true;
    });

    this.setupWindowListeners();
  }

  private setupWindowListeners(): void {
    if (!this.launcherWindow) return;

    this.launcherWindow.on("move", () => {
      if (this.launcherWindow) {
        const bounds = this.launcherWindow.getBounds();
        this.launcherPosition = { x: bounds.x, y: bounds.y };
        this.appState.settingsWindowHelper.reposition(bounds);
      }
    });

    this.launcherWindow.on("resize", () => {
      if (this.launcherWindow) {
        const bounds = this.launcherWindow.getBounds();
        this.launcherSize = { width: bounds.width, height: bounds.height };
        this.appState.settingsWindowHelper.reposition(bounds);
      }
    });

    this.launcherWindow.on("closed", () => {
      this.launcherWindow = null;
      // If launcher closes, we should probably quit app or close overlay
      if (this.overlayWindow && !this.overlayWindow.isDestroyed()) {
        this.overlayWindow.close();
      }
      this.overlayWindow = null;
      this.isWindowVisible = false;
    });

    // Listen for overlay close if independent closing acts as "Stop Meeting"
    if (this.overlayWindow) {
      this.overlayWindow.on("close", (e) => {
        // Prevent accidental closing via cmd+w if we want to enforce workflow?
        // Or treat as end meeting. simpler to treat as hiding for now.
        if (this.isWindowVisible && this.overlayWindow?.isVisible()) {
          e.preventDefault();
          this.switchToLauncher();
          // Notify backend meeting ended? Handled via IPC ideally.
        }
      });
    }
  }

  // Helper to get whichever window should be treated as "Main" for IPC
  public getMainWindow(): BrowserWindow | null {
    if (this.overlayWindow && this.overlayWindow.isVisible()) {
      return this.overlayWindow;
    }
    return this.launcherWindow;
  }

  // Specific getters if needed
  public getLauncherWindow(): BrowserWindow | null {
    return this.launcherWindow;
  }
  public getOverlayWindow(): BrowserWindow | null {
    return this.overlayWindow;
  }
  public getCurrentWindowMode(): "launcher" | "overlay" {
    return this.currentWindowMode;
  }

  public isVisible(): boolean {
    return this.isWindowVisible;
  }

  public hideMainWindow(): void {
    // Hide BOTH
    this.launcherWindow?.hide();
    this.overlayWindow?.hide();
    this.isWindowVisible = false;
  }

  public showMainWindow(): void {
    // Show the window corresponding to the current mode
    if (this.currentWindowMode === "overlay") {
      this.switchToOverlay();
    } else {
      this.switchToLauncher();
    }
  }

  public toggleMainWindow(): void {
    if (this.isWindowVisible) {
      this.hideMainWindow();
    } else {
      this.showMainWindow();
    }
  }

  public centerAndShowWindow(): void {
    // Default to launcher
    this.switchToLauncher();
    this.launcherWindow?.center();
  }

  // --- Swapping Logic ---

  public switchToOverlay(): void {
    console.log("[WindowHelper] Switching to OVERLAY");
    this.currentWindowMode = "overlay";

    // Show Overlay FIRST
    if (this.overlayWindow && !this.overlayWindow.isDestroyed()) {
      // Reset overlay position to center or last known?
      // For now, center it nicely
      const primaryDisplay = screen.getPrimaryDisplay();
      const workArea = primaryDisplay.workAreaSize;
      const x = Math.floor((workArea.width - 600) / 2);
      const y = Math.floor((workArea.height - 600) / 2);

      // Only reset if not already positioned? existing logic used to remember but let's reset for predictability
      this.overlayWindow.setBounds({ x, y, width: 600, height: 600 });

      this.overlayWindow.show();
      this.overlayWindow.focus();
      this.overlayWindow.setAlwaysOnTop(true, "floating");
      this.isWindowVisible = true;
    }

    // Hide Launcher SECOND
    if (this.launcherWindow && !this.launcherWindow.isDestroyed()) {
      this.launcherWindow.hide();
    }
  }

  public switchToLauncher(): void {
    console.log("[WindowHelper] Switching to LAUNCHER");
    this.currentWindowMode = "launcher";

    // Show Launcher FIRST
    if (this.launcherWindow && !this.launcherWindow.isDestroyed()) {
      this.launcherWindow.show();
      this.launcherWindow.focus();
      this.isWindowVisible = true;
      if (process.platform === "darwin") {
        // Only show dock if NOT in stealth mode
        if (!this.appState.getUndetectable()) {
          app.dock.show();
        }
      }
    }

    // Hide Overlay SECOND
    if (this.overlayWindow && !this.overlayWindow.isDestroyed()) {
      this.overlayWindow.hide();
    }
  }

  // Simplified setWindowMode that just calls switchers
  public setWindowMode(mode: "launcher" | "overlay"): void {
    if (mode === "launcher") {
      this.switchToLauncher();
    } else {
      this.switchToOverlay();
    }
  }

  // --- Window Movement (Applies to Overlay mostly, but generalized to active) ---
  private moveActiveWindow(dx: number, dy: number): void {
    const win = this.getMainWindow();
    if (!win) return;

    const [x, y] = win.getPosition();
    win.setPosition(x + dx, y + dy);

    this.currentX = x + dx;
    this.currentY = y + dy;
  }

  public moveWindowRight(): void {
    this.moveActiveWindow(this.step, 0);
  }
  public moveWindowLeft(): void {
    this.moveActiveWindow(-this.step, 0);
  }
  public moveWindowDown(): void {
    this.moveActiveWindow(0, this.step);
  }
  public moveWindowUp(): void {
    this.moveActiveWindow(0, -this.step);
  }
}
